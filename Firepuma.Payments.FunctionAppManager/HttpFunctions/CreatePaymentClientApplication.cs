using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Firepuma.Payments.Core.ValueObjects;
using Firepuma.Payments.FunctionAppManager.Commands;
using Firepuma.Payments.FunctionAppManager.GatewayAbstractions;
using Firepuma.Payments.FunctionAppManager.Infrastructure.Helpers;
using Firepuma.Payments.Infrastructure.Config;
using Firepuma.Payments.Infrastructure.Factories;
using MediatR;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;

// ReSharper disable RedundantNameQualifier

namespace Firepuma.Payments.FunctionAppManager.HttpFunctions;

public class CreatePaymentClientApplication
{
    private readonly ILogger<CreatePaymentClientApplication> _logger;
    private readonly IMediator _mediator;
    private readonly IEnumerable<IPaymentGatewayManager> _gatewayManagers;

    public CreatePaymentClientApplication(
        ILogger<CreatePaymentClientApplication> logger,
        IMediator mediator,
        IEnumerable<IPaymentGatewayManager> gatewayManagers)
    {
        _logger = logger;
        _mediator = mediator;
        _gatewayManagers = gatewayManagers;
    }

    [FunctionName("CreatePaymentClientApplication")]
    public async Task<IActionResult> RunAsync(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = "CreatePaymentClientApplication/{gatewayTypeId}/{applicationId}")] HttpRequest req,
        ILogger log,
        string gatewayTypeId,
        string applicationId,
        CancellationToken cancellationToken)
    {
        log.LogInformation("C# HTTP trigger function processed a request");

        var gatewayManager = _gatewayManagers.GetFromTypeIdOrNull(new PaymentGatewayTypeId(gatewayTypeId));

        if (gatewayManager == null)
        {
            _logger.LogError("The payment gateway manager type \'{GatewayTypeId}\' is not supported", gatewayTypeId);
            return HttpResponseFactory.CreateBadRequestResponse($"The payment gateway manager type '{gatewayTypeId}' is not supported");
        }

        var createClientAppRequest = await gatewayManager.DeserializeCreateClientApplicationRequestAsync(req, cancellationToken);

        if (!createClientAppRequest.IsSuccessful)
        {
            _logger.LogError("{Reason}, {Errors}", createClientAppRequest.FailedReason.ToString(), string.Join(", ", createClientAppRequest.FailedErrors));
            return HttpResponseFactory.CreateBadRequestResponse($"{createClientAppRequest.FailedReason.ToString()}, {string.Join(", ", createClientAppRequest.FailedErrors)}");
        }

        var functionHostKeyName = $"client-app-autogenerated-{applicationId}";

        var newClientAppConfigExtraValues = gatewayManager.CreatePaymentApplicationConfigExtraValues(createClientAppRequest.Result.RequestDto);

        var applicationSecret = PaymentApplicationConfigHelpers.GenerateRandomSecret();
        var newClientAppConfig = new PaymentApplicationConfig
        {
            ApplicationId = new ClientApplicationId(applicationId),
            GatewayTypeId = new PaymentGatewayTypeId(gatewayTypeId),
            ApplicationSecret = applicationSecret,
            ExtraValues = newClientAppConfigExtraValues,
        };

        var commands = new IBaseRequest[]
        {
            new CreateFunctionHostSecretKey.Command(functionHostKeyName),
            new AddClientAppTableRecord.Command(newClientAppConfig),
        };

        var responseObjects = new List<KeyValuePair<string, object>>();
        var logsForResponse = new List<string>();
        foreach (var command in commands)
        {
            var commandName = command.GetType().GetShortTypeName();

            var stopwatch = Stopwatch.StartNew();

            var response = await _mediator.Send(command, cancellationToken);
            responseObjects.Add(new KeyValuePair<string, object>($"{commandName} command", response));

            var durationInSeconds = stopwatch.Elapsed.TotalSeconds.ToString("F");
            logsForResponse.Add($"Command {commandName} duration {durationInSeconds}s");
        }

        responseObjects.Add(new KeyValuePair<string, object>("logs", logsForResponse));

        return new OkObjectResult(new Dictionary<string, object> { { "results", responseObjects } });
    }
}